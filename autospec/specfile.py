#!/usr/bin/python3
#
# specfile.py - part of autospec
# Copyright (C) 2016 Intel Corporation
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Write spec file
#

import types
import re
from collections import OrderedDict

import config
import buildpattern

from util import _file_write


class Specfile(object):
    """
    Holds data and methods needed to write the spec file.
    """

    def __init__(self, url, version, name, release):
        self.url = url
        self.version = version
        self.name = name
        self.release = release
        self.keepstatic = False
        self.urlban = ""
        self.no_autostart = False
        self.specfile = None
        self.sources = {"unit": [], "gcov": [], "tmpfile": [], "archive": []}
        self.default_sum = ""
        self.default_grp = ""
        self.licenses = []
        self.packages = OrderedDict()
        self.main_requires = OrderedDict()
        self.buildreqs = []
        self.pythonreqs = []
        self.patches = []
        self.default_desc = ""
        self.locales = []

    def write_spec(self, path):
        """
        write spec file
        """
        self.specfile = open("{}/{}.spec".format(path, self.name),
                             "w", encoding="utf-8")
        self.specfile.write_strip = types.MethodType(_file_write, self.specfile)
        self._write("#\n")
        self._write("# This file is auto-generated. DO NOT EDIT\n")
        self._write("# Generated by: autospec.py\n")
        self._write("#\n")

        if self.keepstatic:
            self._write("%define keepstatic 1\n")

        # general package header
        self.write_nvr()
        self.write_sources()
        self.write_summary()
        self.write_license()

        self.write_main_subpackage_requires()
        self.write_buildreq()
        self.write_patch_header()

        # main package extra content
        self.write_description()
        self.write_files_header()

        # build instructions
        self.write_buildpattern()

        # scriplets
        self.write_scriplets()

        # %files
        self.write_files()
        self.write_lang_files()

        self.specfile.close()

    def write_nvr(self):
        """
        Write name, version, and release information.
        """
        print("specrelease", self.release)
        if self.urlban:
            self.url = re.sub(self.urlban, "localhost", self.url)
        self._write("Name     : {}\n".format(self.name))
        self._write("Version  : {}\n".format(self.version))
        self._write("Release  : {}\n".format(str(self.release)))
        self._write("URL      : {}\n".format(self.url))
        self._write("Source0  : {}\n".format(self.url))

    def write_sources(self):
        """
        Append additional source files - systemd unit files, gcov, and
        additional source tarballs are the currently supported file types.
        """
        for count, source in enumerate(sorted(self.sources["unit"] +
                                              self.sources["archive"] +
                                              self.sources["tmpfile"] +
                                              self.sources["gcov"])):
            buildpattern.source_index[source] = count + 1  # needed?
            self._write("Source{0}  : {1}\n".format(count + 1, source))

    def write_summary(self):
        """
        Write package summary to spec file
        """
        self._write("Summary  : {}\n".format(self.default_sum.strip()))
        self._write("Group    : {}\n".format(self.default_grp.strip()))

    def write_license(self):
        """
        Write license information to spec file
        """
        self._write("License  : {}\n".format(" ".join(sorted(self.licenses))))

    def write_main_subpackage_requires(self):
        """
        Write subpackage build requirements
        """
        for pkg in self.packages:
            if pkg == "autostart" and self.no_autostart:
                continue
            if pkg in ["ignore", "main", "dev", "active-units", "extras",
                       "lib32", "dev32"]:
                continue
            self._write("Requires: {}-{}\n".format(self.name, pkg))

        for pkg in self.main_requires:
            self._write("Requires: {}\n".format(pkg))

    def write_buildreq(self):
        """
        Write build requirements
        """
        for req in sorted(self.buildreqs):
            self._write("BuildRequires : {}\n".format(req))

    def write_patch_header(self):
        """
        Write patch list header
        """
        for count, patch in enumerate(self.patches):
            self._write("Patch{0}: {1}\n".format(count + 1, patch.split()[0]))

    def write_description(self):
        """
        Write package description
        """
        self._write("\n%description\n{}\n".format(self.default_desc.strip()))

    def write_files_header(self):
        """
        Write file headers to spec file
        """
        groups = {}
        groups["dev"] = "Development"
        groups["bin"] = "Binaries"
        groups["lib"] = "Libraries"
        groups["doc"] = "Documentation"
        groups["data"] = "Data"

        deps = {}
        deps["dev"] = ["lib", "bin", "data"]
        deps["dev32"] = ["lib32", "bin", "data", "dev"]
        deps["bin"] = ["data", "config", "setuid", "attr"]
        deps["lib"] = ["data", "config"]
        deps["lib32"] = ["data", "config"]

        provides = {}
        provides["dev"] = ["devel"]

        for pkg in sorted(self.packages):
            if pkg in ["ignore", "main"]:
                continue

            self._write("\n%package {}\n".format(pkg))
            self._write("Summary: {} components for the {} package.\n"
                        .format(pkg, self.name))
            if pkg in groups:
                self._write("Group: {}\n".format(groups[pkg]))
            else:
                self._write("Group: Default\n")

            for dep in deps.get(pkg, []):
                if dep in self.packages:
                    self._write("Requires: {}-{}\n".format(self.name, dep))

            for prov in provides.get(pkg, []):
                self._write("Provides: {}-{}\n".format(self.name, prov))

            if pkg == "python":
                if self.name != self.name.lower():
                    self._write("Provides: {}-python\n".format(self.name.lower()))

                for req in sorted(self.pythonreqs):
                    if req in self.buildreqs:
                        self._write("Requires: {}\n".format(req))

            self._write("\n%description {}\n".format(pkg))
            self._write("{} components for the {} package.\n".format(pkg, self.name))
            self._write("\n")

    def write_buildpattern(self):
        """
        Write build pattern to spec file.

        Currently depends on buildpattern.py due to pattern-matched methods
        """
        buildpattern.write_buildpattern(self.specfile)

    def write_scriplets(self):
        """
        Write post and pre scripts to spec file
        """
        for pkg in sorted(self.packages):
            if pkg in ["ignore", "main", "locales"]:
                continue

            for script in ["post", "pre"]:
                content = config.read_conf_file("{}.{}".format(script, pkg))
                if content:
                    self._write("\n%{0} {1}\n".format(script, pkg))
                    self.specfile.writelines(content)

    def write_files(self):
        """
        Write %files section to spec file
        """
        self._write("\n%files\n")
        self._write("%defattr(-,root,root,-)\n")
        if "main" in self.packages:
            for filename in sorted(self.packages["main"]):
                self._write("{}\n".format(filename))

        for pkg in sorted(self.packages):
            if pkg in ["ignore", "main", "locales"]:
                continue

            self._write("\n%files {}\n".format(pkg))
            self._write("%defattr(-,root,root,-)\n")
            for filename in sorted(self.packages[pkg]):
                self._write("{}\n".format(filename))

    def write_lang_files(self):
        """
        Write lang files to spec
        """
        if not self.locales:
            return

        self._write("\n%files locales ")
        for lang in self.locales:
            self._write("-f {}.lang".format(lang))

        self._write("\n%defattr(-,root,root,-)\n\n")

    def _write(self, string):
        self.specfile.write(string)
